<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body marginheight="0"><h2>http缓存</h2>
<p>将请求的资源缓存到浏览器端。如果浏览器端的缓存资源可用，那么服务器就不会返回相应的资源。这样我们的程序又快了一点。
本质上，客户端通过将记号传回服务器要求服务器验证其（客户端）缓存。

</p>
<h4>技术点：</h4>
<ol>
<li>在控制器中定义behaviors方法，在该方法中进行相关配置；</li>
<li>用到 yii\filters\HttpCache 类</li>
<li>last-modified配置</li>
<li>etag配置</li>
</ol>
<h4>http缓存的原理：</h4>
<p>情况1：:当浏览器向服务器发送请求的时候，服务器会将数据响应给浏览器。为了避免浏览器在较短时间内频繁向服务器发送请求，导致服务器频繁响应资源数据，服务器在第一次响应数据的时候，会附带一个响应字段last-modified，添加到响应头部，传给浏览器，此时数据和last-modified都被缓存在了浏览器端。当浏览器再次向服务器发送请求的时候，浏览器会将last-modified发送给服务器。服务器通过校验浏览器发送过来的last-modified与服务器端存储的资源的修改时间来判断二者是否一致。如果一致，那么就不会再次返回资源，而是告诉浏览器直接使用缓存即可。如果不一致，那么服务器端会重复响应的步骤。

</p>
<blockquote>
<p>总结一下：若服务器端资源的修改时间发生了变化，那么浏览器端的缓存释放。

</p>
</blockquote>
<p>情况2：服务端的资源修改时间发生了变化，但是服务端资源内容无任何变化的情况下，last-modified却依然起作用。为了解决这种情况，当浏览器向服务器发送请求的时候，为了避免服务器再次将相同的内容响应给浏览器，服务器在第一次响应数据的时候，还要根据资源的内容生成一个etag，并将其连同last-modified和数据一起响应给浏览器，供浏览器缓存。当浏览器第二次请求相同地址的资源的时候，浏览器将其缓存的etag、last-modified一同发送给服务器。服务器通过检测服务端资源的etag与浏览器端发送过来的etag是否一致，来决定是否响应数据。如果不一致，那么返回资源，并重复之前的响应步骤，否则告诉浏览直接使用缓存。

</p>
<blockquote>
<p>注意：当last-modified与etag同时设置的时候，其实起决定作用是etag，如果etag不变，那么无论last-modified是否变化，浏览器端缓存都不会释放。如果etag发生改变，同样无论last-modified是否变化，浏览器端缓存都会被释放。 
Edit By <a href="http://mahua.jser.me">MaHua</a></p>
</blockquote>
</body></html>